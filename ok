#!/usr/bin/env bash

# tip: "." (i.e. source) this file from your profile (.bashrc), e.g. ". ~/ok"

ok() {
    function cmd_usage {
        echo 'Usage: ok [ok-options] <number> [script-options..]
                     ok command [options]

command (use one):
  <number>        Run the <number>th command from the ".ok" file
  l, list         Show the list from the ".ok" file
  L, list-once    Same as list, but only show when pwd is different from previous run
  p, list-prompt  Default command. Show the list and wait for prompt (--list and <number> in one command)
  h, help         Show this usage page
ok-options:
  -v, --verbose   Show more output, most of the time to stderr
  -, --           Next options will be passed as <script-options> (see next)
script-options:
  ...             These are passed through, when a line is executed
'
        if [[ -n $1 ]]; then
        	echo "$1"
            echo
        fi
    }

    function cmd_run {
        local LINE_NR=$1
        shift
        # save and remove argument. Remaining arguments are passwed to eval automatically
        local LINE_TEXT=$( cat .ok | grep -vE "^#" | sed ${LINE_NR}'!d' )
        if [[ -n $LINE_TEXT ]]; then
            # output the command first
            echo -e "${C_PROMPT}${PROMPT}${C_COMMAND}${LINE_TEXT}${C_NC}" | sed -E "s/(#.*)\$/${C_COMMENT}\1/1"
            # remove commented lines, and execute that line from the file
            eval $LINE_TEXT
        else
            if [[ $verbose == 1 ]]; then
                >&2 echo "ERROR: entered line number '$LINE_NR' does not exist"
            fi
        fi
    }

    function cmd_list {
        # list the content of the file, with a number (1-based) before each line,
        # except lines starting with a "#", those are printed red without a number) as headers
        cat .ok | awk -v h=$C_HEADING -v n=$C_NUMBER -v c=$C_COMMENT -v m=$C_COMMAND -v x=$C_NC $'
            $0 ~ /^#/ {
                #print the (sub-)headings
                print x h $0 x;
            }
            $0 ~ /^[^#]/ {
                #print the commands
                sub(/#/,c "#");
                print x n "" ++i "." m " " $0 x;
            }'
    }

    # handle command line arguments first
    local re_is_num='^[0-9]+$'
    local cmd='list'
    local line_nr=0
    local once_check=0
    local show_prompt=1
    local usage_error=
    local verbose=0
    while (( $# > 0 )) ; do
        if [[ $1 =~ $re_is_num ]]; then
            cmd='run'
            line_nr=$1
            shift; break
        else
            case $1 in
                #commands
                l | list)          cmd=list;;
                L | list-once)     cmd=list; once_check=1;;
                p | list-prompt)   cmd=list; show_prompt=1;;
                h | help)          cmd=usage;;
                #options
                -\? | -h | --help) cmd=usage;;
                -v | --verbose)    verbose=1;;
                - | --)            shift; break;;
                *)                 cmd=usage; usage_error="Unknown command/option '$1'";;
            esac
        fi
        shift
    done

    # used for colored output (see: https://stackoverflow.com/a/20983251/56)
    local C_NC=$(tput sgr 0)
    if [ -z ${_OK_C_HEADING+x} ]; then local C_HEADING=$(tput setaf 1); else local C_HEADING=$_OK_C_HEADING; fi #HEADING defaults to RED
    if [ -z ${_OK_C_NUMBER+x} ];  then local C_NUMBER=$(tput setaf 6);  else local C_NUMBER=$_OK_C_NUMBER;   fi #NUMBER defaults to CYAN
    if [ -z ${_OK_C_COMMENT+x} ]; then local C_COMMENT=$(tput setaf 4); else local C_COMMENT=$_OK_C_COMMENT; fi #COMMENT defaults to BLUE
    if [ -z ${_OK_C_COMMAND+x} ]; then local C_COMMAND=$C_NC;           else local C_COMMAND=$_OK_C_COMMAND; fi #COMMAND defaults to NO COLOR
    if [ -z ${_OK_C_PROMPT+x} ];  then local C_PROMPT=$C_NUMBER;        else local C_PROMPT=$_OK_C_PROMPT;   fi #PROMPT defaults to same color as NUMBER
    # other customizations
    if [ -z ${_OK_PROMPT+x} ];    then local PROMPT="$ ";               else local PROMPT=$_OK_PROMPT;       fi

    # if there is a file called .ok...
    if [ -f .ok ]; then
        # if the user provided a parameter, $1, which contains a number...
        if [[ $cmd == run ]]; then
            cmd_run $line_nr "$@"
        elif [[ $cmd == list ]]; then
            if [[ $once_check == 0 || ($once_check == 1 && $_OK_LAST_PWD != $(pwd)) ]]; then
                cmd_list
                if [[ $show_prompt == 1 ]]; then
                    read -p "${_OK_C_PROMPT}${PROMPT}${C_NC}" line_nr
                    if [[ $line_nr =~ $re_is_num ]]; then
                        cmd_run $line_nr "$@"
                    else
                        if [[ $verbose == 1 ]]; then
                            >&2 echo "ERROR: entered line number '$LINE_NR' is not a number"
                        fi
                    fi
                fi
            fi
            if [[ $verbose = 1 && $once_check == 1 && $_OK_LAST_PWD == $(pwd) ]]; then
                echo "The listing for this folder has already been shown"
            fi
        elif [[ $cmd == usage ]]; then
            cmd_usage "$usage_error"
        fi
        export _OK_LAST_PWD=$(pwd)
    else
        if [[ $verbose == 1 ]]; then
            echo "Nothing to do: this folder doesn't have an '.ok' file"
        fi
    fi
}
